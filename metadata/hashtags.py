"""Generate platform-specific hashtags."""

import logging
from typing import Dict, List, Set

logger = logging.getLogger(__name__)

# Platform-specific hashtag limits
HASHTAG_LIMITS = {
    "TikTok": 30,
    "Instagram": 30,
    "YouTube": 15
}

# Common broad hashtags for reach
BROAD_HASHTAGS = {
    "TikTok": ["#fyp", "#foryou", "#viral", "#trending"],
    "Instagram": ["#reels", "#reelsinstagram", "#viral", "#explore"],
    "YouTube": ["#shorts", "#youtubeshorts", "#viral"]
}


def resolve_hashtags(
    user_tags: List[str],
    ai_tags: List[str],
    mode: str = "append"
) -> List[str]:
    """
    Resolve final hashtag list according to the specified mode.

    Modes:
        "strict"  - Use only user-defined hashtags; ignore AI tags entirely.
        "append"  - Append AI-generated tags after user tags, de-duplicating.
        "ai_only" - Use only AI-generated hashtags; ignore user tags.

    Args:
        user_tags: Hashtags provided by the user
        ai_tags:   Hashtags generated by AI
        mode:      One of "strict", "append", or "ai_only" (default: "append")

    Returns:
        Resolved list of hashtags
    """
    if mode == "strict":
        # Returns empty list if user_tags is empty; callers should warn appropriately.
        return list(user_tags)

    if mode == "append":
        combined = list(user_tags)
        for tag in ai_tags:
            if tag not in combined:
                combined.append(tag)
        return combined

    # "ai_only"
    return list(ai_tags)


def generate_hashtags(
    clip: Dict,
    platforms: List[str] = None,
    max_hashtags: int = 10,
    user_tags: List[str] = None,
    hashtag_mode: str = "append"
) -> Dict[str, List[str]]:
    """
    Generate platform-optimized hashtags for a clip.

    Respects user-defined hashtags according to hashtag_mode:
        "strict"  - Use only user-defined hashtags.
        "append"  - Append AI/broad tags after user tags (default).
        "ai_only" - Use only AI-generated tags.

    Args:
        clip: Clip dictionary with AI analysis
        platforms: List of target platforms (defaults to all)
        max_hashtags: Maximum number of hashtags per platform
        user_tags: Hashtags provided by the user (optional)
        hashtag_mode: One of "strict", "append", or "ai_only"

    Returns:
        Dictionary mapping platform names to hashtag lists
    """
    if platforms is None:
        platforms = ["TikTok", "Instagram", "YouTube"]

    if user_tags is None:
        user_tags = []

    hashtags_by_platform = {}

    # Get AI-generated hashtags if available
    ai_analysis = clip.get("ai_analysis", {})
    ai_hashtags = ai_analysis.get("hashtags", [])

    # Clean and normalize AI hashtags
    niche_hashtags = []
    for tag in ai_hashtags:
        # Ensure hashtag format
        if not tag.startswith("#"):
            tag = f"#{tag}"
        # Remove spaces
        tag = tag.replace(" ", "")
        niche_hashtags.append(tag.lower())

    # Deduplicate
    niche_hashtags = list(dict.fromkeys(niche_hashtags))

    for platform in platforms:
        platform_limit = min(
            HASHTAG_LIMITS.get(platform, 30),
            max_hashtags
        )

        # Start with platform-specific broad hashtags
        broad = BROAD_HASHTAGS.get(platform, [])

        # Build AI/broad candidate pool (trim to platform_limit to avoid unnecessary work)
        ai_pool = broad.copy()
        for tag in niche_hashtags:
            if len(ai_pool) >= platform_limit:
                break
            if tag not in ai_pool:
                ai_pool.append(tag)

        # If we still need more hashtags, add generic ones
        if len(ai_pool) < 5:
            generic = ["#content", "#video", "#viral", "#trending", "#fyp"]
            for tag in generic:
                if len(ai_pool) >= platform_limit:
                    break
                if tag not in ai_pool:
                    ai_pool.append(tag)

        # Warn when strict mode is used with no user tags (would produce empty list)
        if hashtag_mode == "strict" and not user_tags:
            logger.warning(
                f"hashtag_mode='strict' but no user_tags provided for {platform}; "
                "resulting hashtag list will be empty"
            )

        # Resolve final hashtag list using user priority logic
        hashtags = resolve_hashtags(user_tags, ai_pool, mode=hashtag_mode)

        hashtags_by_platform[platform] = hashtags[:platform_limit]

        logger.debug(f"Generated {len(hashtags_by_platform[platform])} hashtags for {platform}")

    return hashtags_by_platform


def extract_keywords_from_text(text: str, max_keywords: int = 5) -> List[str]:
    """
    Extract potential hashtag keywords from text.
    
    Args:
        text: Clip text
        max_keywords: Maximum keywords to extract
        
    Returns:
        List of keyword strings
    """
    # Simple keyword extraction (can be enhanced with NLP)
    words = text.lower().split()
    
    # Filter out common words
    stop_words = {
        "the", "a", "an", "and", "or", "but", "in", "on", "at",
        "to", "for", "of", "with", "by", "from", "is", "was",
        "are", "were", "be", "been", "being", "have", "has", "had"
    }
    
    keywords = []
    for word in words:
        # Clean word
        clean_word = word.strip('.,!?;:"\'-')
        
        # Skip if too short, too long, or stop word
        if len(clean_word) < 3 or len(clean_word) > 20:
            continue
        if clean_word in stop_words:
            continue
        
        if clean_word not in keywords:
            keywords.append(clean_word)
        
        if len(keywords) >= max_keywords:
            break
    
    return keywords
